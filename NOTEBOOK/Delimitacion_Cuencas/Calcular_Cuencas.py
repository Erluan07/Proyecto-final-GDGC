# -*- coding: utf-8 -*-
# ---------------------------------------------------------------------------
# P_Morfo_Ciclo.py
# Created on: 2024-04-16 11:28:30.00000
#   (generated by ArcGIS/ModelBuilder)
# Usage: P_Morfo_Ciclo <Input_Dem> <Input_Point> <Workspace> 
# Description: 
# Ezequiel De Jesús Ferro Palacios
# Universidad Nacional
# ejferrop@unal.edu.co

# ---------------------------------------------------------------------------


import arcpy

import arcpy
import os

arcpy.env.overwriteOutput = True

# Argumentos del script
Input_Dem = arcpy.GetParameterAsText(0)
Orden_maximo = int(arcpy.GetParameterAsText(1))
Orden_minimo = int(arcpy.GetParameterAsText(2))
Area_Maxima = float(1000000 * 400)
Area_Minima = float(1000000 * 50)


arcpy.env.overwriteOutput = True

# Obtener directorio de DEM
arcpy.AddMessage("Obteniendo directorio de trabajo...")
DES_DEM = arcpy.Describe(Input_Dem)
Workspace = DES_DEM.path + "\\"
arcpy.AddMessage("...completado")

# Local variables:
Fill_tif = Workspace + "Fill.tif"
Output_drop_raster = ""
FlowDir_tif = Workspace + "FlowDir.tif"
FlowAcc_tif = Workspace + "FlowAcc.tif"
rastercal_tif = Workspace + "rastercal.tif"
StreamO_tif = Workspace + "StreamO.tif"
Drenajes_Prev_shp = Workspace + "Drenajes_Prev.shp"
Point_Layer = "Igua_Point_Layer"
Watersh_tif = Workspace + "Watersh.tif"
Cuenca_value__shp = Workspace + "Cuenca%value%.shp"
Cuenca_T = Cuenca_value__shp
Fill_Clip_tif = Workspace + "Fill_Clip.tif"
Slope_tif = Workspace + "Slope.tif"
Reclas_Slop_tif = Workspace + "Reclas_Slop.tif"
ZonalSt_Slope = Workspace + "ZonalSt_Slope"
Zonal_Slope_value__xls = Workspace + "Zonal_Slope%value%.xls"
Delete_succeeded = "true"
Drenajes_value__shp = Workspace + "Drenajes%value%.shp"
Drenajes_shp__3_ = Drenajes_value__shp
Drenajes_shp__2_ = Drenajes_shp__3_
Drenajes_Table_value__xls = Workspace + "Drenajes_Table%value%.xls"
Delete_succeeded__2_ = "true"
Delete_succeeded__3_ = "true"
Delete_succeeded__5_ = "true"
Delete_succeeded__6_ = "true"
Delete_succeeded__7_ = "true"
Delete_succeeded__8_ = "true"
Delete_succeeded__9_ = "true"
Datos_Cuenca_value__xls = Workspace + "Datos_Cuenca%value%.xls"
Cuenca_MBG_value_ = Workspace + "Cuenca_MBG%value%"
Cuenca_MBG_value__xls = Workspace + "Cuenca_MBG%value%.xls"
DEM_Clip_tif = Workspace + "DEM_Clip.tif"
Reclass_dem_tif = Workspace + "Reclass_dem.tif"
ZonalDem = Workspace + "ZonalDem"
Areas_Curva_value__xls = Workspace + "Areas_Curva%value%.xls"
Delete_succeeded__4_ = "true"
Delete_succeeded__10_ = "true"
Delete_succeeded__11_ = "true"
Delete_succeeded__12_ = "true"
Delete_succeeded__13_ = "true"
Delete_succeeded__14_ = "true"
Delete_succeeded__15_ = "true"
Delete_succeeded__16_ = "true"
Delete_succeeded__17_ = "true"
Delete_succeeded__18_ = "true"
Delete_succeeded__19_ = "true"



arcpy.AddMessage("Process: Fill")
arcpy.gp.Fill_sa(Input_Dem, Fill_tif, "")

arcpy.AddMessage("Process: Flow Direction")
arcpy.gp.FlowDirection_sa(Fill_tif, FlowDir_tif, "NORMAL", Output_drop_raster, "D8")


arcpy.AddMessage("Process: Flow Accumulation")
arcpy.gp.FlowAccumulation_sa(FlowDir_tif, FlowAcc_tif, "", "FLOAT", "D8")

arcpy.AddMessage("Expresion para la calculadora de raster")
expression = "Con(\"{}\" >= 1000, 1)".format(FlowAcc_tif)

arcpy.AddMessage("Ejecutar la calculadora de raster")
arcpy.gp.RasterCalculator_sa(expression, rastercal_tif)


arcpy.AddMessage("Process: Stream Order")
arcpy.gp.StreamOrder_sa(rastercal_tif, FlowDir_tif, StreamO_tif, "STRAHLER")

arcpy.AddMessage("Process: Stream to Feature")
arcpy.gp.StreamToFeature_sa(StreamO_tif, FlowDir_tif, Drenajes_Prev_shp, "NO_SIMPLIFY")


#=============================================================================
#==============DEFINIR CUENCAS ===============================================

# Process: Unsplit Line (Unsplit Line) (management)
Drenajes_UnSplit = Workspace + "Drenajes_UnSplit.shp"
arcpy.management.UnsplitLine(in_features=Drenajes_Prev_shp, out_feature_class=Drenajes_UnSplit_shp, dissolve_field=[], statistics_fields=[], concatenation_separator="")
# Process: Unsplit Line
arcpy.UnsplitLine_management(Drenajes_Prev_shp, Drenajes_UnSplit, "grid_code", "")

# Crear una capa para las cuencas finales
Cuencas_final = os.path.join(Workspace, "Cuencas_final.shp")
if arcpy.Exists(Cuencas_final):
    arcpy.Delete_management(Cuencas_final)
arcpy.CreateFeatureclass_management(Workspace, "Cuencas_final.shp", "POLYGON", spatial_reference=arcpy.Describe(Drenajes_UnSplit).spatialReference)


# Agregar campo de área a la capa final
arcpy.AddField_management(Cuencas_final, "Area", "DOUBLE")


# Ciclo para repetir el proceso varias veces
for i in range(Orden_maximo, Orden_minimo - 1, -1):
    arcpy.AddMessage(u"Procesando orden " + str(i))
    
    # Proceso: Seleccionar capa por atributo
    arcpy.AddMessage(u"Creando capa temporal...")
    arcpy.MakeFeatureLayer_management(Drenajes_UnSplit, "Drenajes_UnSplit_lyr")

    where_clause = u"grid_code = " + str(i) + u" OR grid_code = " + str(i-1)
    arcpy.AddMessage(u"Seleccionando con where_clause: " + where_clause)
    arcpy.SelectLayerByAttribute_management("Drenajes_UnSplit_lyr", "NEW_SELECTION", where_clause)

    # Exportar la selección a una nueva capa temporal
    temp_layer = os.path.join(Workspace, "temp_selection.shp")
    arcpy.AddMessage(u"Exportando selección a: " + temp_layer.decode('utf-8'))
    arcpy.CopyFeatures_management("Drenajes_UnSplit_lyr", temp_layer)

    # Verificar si la capa temporal se creó correctamente
    if not arcpy.Exists(temp_layer):
        arcpy.AddError(u"No se pudo crear la capa temporal: " + temp_layer.decode('utf-8'))
        continue

    # Nombre dinámico para el resultado de la intersección
    UnSplitX1_Inter = os.path.join(Workspace, "UnSplitX1_Inter_" + str(i) + ".shp")
    arcpy.AddMessage(u"Realizando intersección. Resultado: " + UnSplitX1_Inter.decode('utf-8'))

    # Proceso: Intersección usando la capa temporal
    arcpy.Intersect_analysis([temp_layer], UnSplitX1_Inter, "ALL", "", "POINT")

    # Eliminar la capa temporal
    arcpy.AddMessage(u"Eliminando capa temporal...")
    arcpy.Delete_management(temp_layer)

    # Nombre dinámico para Snap Pour Point
    SnapPou_UnSp = "{}SnapPou_UnSp{}".format(Workspace, i)

    # Proceso: Snap Pour Point
    arcpy.gp.SnapPourPoint_sa(UnSplitX1_Inter, FlowAcc_tif, SnapPou_UnSp, "0", "FID")

    # Nombre dinámico para Watershed
    Watersh = "{}Watersh{}".format(Workspace, i)

    # Proceso: Watershed
    arcpy.gp.Watershed_sa(FlowDir_tif, SnapPou_UnSp, Watersh, "")

    # Nombre dinámico para Raster to Polygon
    Cuencas_shp = os.path.join(Workspace, "Cuencas_{}.shp".format(i))

    # Proceso: Convertir raster a polígono
    arcpy.RasterToPolygon_conversion(Watersh, Cuencas_shp, "SIMPLIFY", "", "SINGLE_OUTER_PART", "")

    # Agregar campo de área
    arcpy.AddField_management(Cuencas_shp, "Area", "DOUBLE")

    # Calcular el área de los polígonos
    arcpy.AddMessage(u"Calculando área para: " + Cuencas_shp)
    arcpy.CalculateField_management(Cuencas_shp, "Area", "!shape.area!", "PYTHON_9.3")

    ## Crear una capa temporal del shapefile de cuencas
    arcpy.AddMessage(u"Creando capa temporal de: " + Cuencas_shp)
    arcpy.MakeFeatureLayer_management(Cuencas_shp, "Cuencas_lyr")

    # Seleccionar cuencas fuera del rango de área (tanto por encima como por debajo)
    where_clause = "Area < {} OR Area > {}".format(Area_Minima, Area_Maxima)
    arcpy.AddMessage(u"Seleccionando cuencas fuera del rango de área con where_clause: " + where_clause)
    arcpy.SelectLayerByAttribute_management("Cuencas_lyr", "NEW_SELECTION", where_clause)

    # Contar cuántas cuencas fueron seleccionadas (fuera del rango)
    result = arcpy.GetCount_management("Cuencas_lyr")
    count_selected = int(result.getOutput(0))
    arcpy.AddMessage(u"Número de cuencas fuera del rango de área: {}".format(count_selected))

    if count_selected > 0:
        # Eliminar las cuencas fuera del rango de área
        arcpy.AddMessage(u"Eliminando cuencas fuera del rango de área")
        arcpy.DeleteFeatures_management("Cuencas_lyr")
    else:
        arcpy.AddMessage(u"No se encontraron cuencas fuera del rango de área")

    # Limpiar la selección
    arcpy.SelectLayerByAttribute_management("Cuencas_lyr", "CLEAR_SELECTION")

    # Contar cuántas cuencas quedan después de la eliminación
    result = arcpy.GetCount_management(Cuencas_shp)
    count = int(result.getOutput(0))
    arcpy.AddMessage(u"Número de cuencas restantes: {}".format(count))

    # Calcular estadísticas de área después de la selección
    arcpy.Statistics_analysis(Cuencas_shp, "in_memory/stats_final", [["Area", "MIN"], ["Area", "MAX"], ["Area", "MEAN"]])
    with arcpy.da.SearchCursor("in_memory/stats_final", ["MIN_Area", "MAX_Area", "MEAN_Area"]) as cursor:
        for row in cursor:
            arcpy.AddMessage(u"Estadísticas de área después de la selección - Mínima: {}, Máxima: {}, Media: {}".format(row[0], row[1], row[2]))

    # Imprimir áreas de las primeras 5 cuencas restantes
    arcpy.AddMessage(u"Áreas de las primeras 5 cuencas restantes:")
    with arcpy.da.SearchCursor(Cuencas_shp, ["Area"]) as cursor:
        for i, row in enumerate(cursor):
            if i < 5:
                arcpy.AddMessage(u"Cuenca {}: Área = {}".format(i+1, row[0]))
            else:
                break

    # Eliminar la capa temporal al final
    arcpy.Delete_management("Cuencas_lyr")

    # Contar cuántas cuencas quedan después de la eliminación
    result = arcpy.GetCount_management(Cuencas_shp)
    count = int(result.getOutput(0))
    arcpy.AddMessage(u"Número de cuencas restantes: {}".format(count))


    # Finalmente, puedes agregar un mensaje para indicar que el procesamiento para este orden ha terminado
    arcpy.AddMessage(u"Procesamiento completado para el orden {}".format(i))

    # Fuera del bucle for, podrías agregar algún mensaje de finalización
    arcpy.AddMessage(u"Procesamiento completo para todos los órdenes")


   
    # Al final del bucle, después de procesar las cuencas individuales:
    arcpy.AddMessage(u"Agregando cuencas de orden {} a la capa final".format(i))
    
    # Crear capas temporales
    arcpy.MakeFeatureLayer_management(Cuencas_shp, "Cuencas_{}".format(i))
    arcpy.MakeFeatureLayer_management(Cuencas_final, "Cuencas_final_lyr")
    
    # Seleccionar las cuencas que no se solapan con las cuencas ya existentes en la capa final
    arcpy.SelectLayerByLocation_management("Cuencas_{}".format(i), "HAVE_THEIR_CENTER_IN", "Cuencas_final_lyr", "", "NEW_SELECTION", "INVERT")
    
    # Contar cuántas cuencas fueron seleccionadas
    result = arcpy.GetCount_management("Cuencas_{}".format(i))
    count_selected = int(result.getOutput(0))
    arcpy.AddMessage(u"Número de cuencas de orden {} a agregar: {}".format(i, count_selected))
    
    if count_selected > 0:
        # Configurar el mapeo de campos para la operación Append
        field_mapping = arcpy.FieldMappings()
        field_mapping.addTable(Cuencas_final)
        field_mapping.addTable("Cuencas_{}".format(i))
        
        # Agregar las cuencas seleccionadas a la capa final
        arcpy.Append_management("Cuencas_{}".format(i), Cuencas_final, "NO_TEST", field_mapping)
        arcpy.AddMessage(u"Cuencas de orden {} agregadas a la capa final".format(i))
    else:
        arcpy.AddMessage(u"No se encontraron cuencas de orden {} para agregar".format(i))
    
    # Limpiar las capas temporales
    arcpy.Delete_management("Cuencas_{}".format(i))
    arcpy.Delete_management("Cuencas_final_lyr")

# Fuera del bucle for, agregar un mensaje de finalización
arcpy.AddMessage(u"Procesamiento completo para todos los órdenes")
arcpy.AddMessage(u"Capa final de cuencas creada en: {}".format(Cuencas_final))

# Calcular el área para la capa final
arcpy.CalculateField_management(Cuencas_final, "Area", "!shape.area!", "PYTHON_9.3")

# Calcular estadísticas finales
arcpy.AddMessage(u"Calculando estadísticas finales")
field_names = [f.name for f in arcpy.ListFields(Cuencas_final)]
if "Area" in field_names:
    arcpy.Statistics_analysis(Cuencas_final, "in_memory/stats_final", [["Area", "MIN"], ["Area", "MAX"], ["Area", "MEAN"]])
    with arcpy.da.SearchCursor("in_memory/stats_final", ["MIN_Area", "MAX_Area", "MEAN_Area"]) as cursor:
        for row in cursor:
            arcpy.AddMessage(u"Estadísticas de área de la capa final - Mínima: {}, Máxima: {}, Media: {}".format(row[0], row[1], row[2]))
else:
    arcpy.AddError("El campo 'Area' no existe en la capa final de cuencas.")

# Contar el número total de cuencas en la capa final
result = arcpy.GetCount_management(Cuencas_final)
count_final = int(result.getOutput(0))
arcpy.AddMessage(u"Número total de cuencas en la capa final: {}".format(count_final))


#=============================================================================
# Obtener el número total de cuencas en Cuencas_final
result = arcpy.GetCount_management(Cuencas_final)
num_cuencas = int(result.getOutput(0))

arcpy.AddMessage("Número total de cuencas a procesar: {}".format(num_cuencas))